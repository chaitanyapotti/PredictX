schema {
  query: Query
  subscription: Subscription
}

"""
Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive.
"""
directive @entity on OBJECT

"""Defined a Subgraph ID for an object type"""
directive @subgraphId(id: String!) on OBJECT

"""
creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API.
"""
directive @derivedFrom(field: String!) on FIELD_DEFINITION

type Query {
  marketAsserted(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MarketAsserted
  marketAsserteds(
    skip: Int = 0
    first: Int = 100
    orderBy: MarketAsserted_orderBy
    orderDirection: OrderDirection
    where: MarketAsserted_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MarketAsserted!]!
  marketInitialized(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MarketInitialized
  marketInitializeds(
    skip: Int = 0
    first: Int = 100
    orderBy: MarketInitialized_orderBy
    orderDirection: OrderDirection
    where: MarketInitialized_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MarketInitialized!]!
  marketResolved(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MarketResolved
  marketResolveds(
    skip: Int = 0
    first: Int = 100
    orderBy: MarketResolved_orderBy
    orderDirection: OrderDirection
    where: MarketResolved_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MarketResolved!]!
  tokensBought(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokensBought
  tokensBoughts(
    skip: Int = 0
    first: Int = 100
    orderBy: TokensBought_orderBy
    orderDirection: OrderDirection
    where: TokensBought_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokensBought!]!
  tokensCreated(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokensCreated
  tokensCreateds(
    skip: Int = 0
    first: Int = 100
    orderBy: TokensCreated_orderBy
    orderDirection: OrderDirection
    where: TokensCreated_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokensCreated!]!
  tokensRedeemed(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokensRedeemed
  tokensRedeemeds(
    skip: Int = 0
    first: Int = 100
    orderBy: TokensRedeemed_orderBy
    orderDirection: OrderDirection
    where: TokensRedeemed_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokensRedeemed!]!
  tokensSettled(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokensSettled
  tokensSettleds(
    skip: Int = 0
    first: Int = 100
    orderBy: TokensSettled_orderBy
    orderDirection: OrderDirection
    where: TokensSettled_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokensSettled!]!
  tokensSold(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokensSold
  tokensSolds(
    skip: Int = 0
    first: Int = 100
    orderBy: TokensSold_orderBy
    orderDirection: OrderDirection
    where: TokensSold_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokensSold!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type Subscription {
  marketAsserted(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MarketAsserted
  marketAsserteds(
    skip: Int = 0
    first: Int = 100
    orderBy: MarketAsserted_orderBy
    orderDirection: OrderDirection
    where: MarketAsserted_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MarketAsserted!]!
  marketInitialized(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MarketInitialized
  marketInitializeds(
    skip: Int = 0
    first: Int = 100
    orderBy: MarketInitialized_orderBy
    orderDirection: OrderDirection
    where: MarketInitialized_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MarketInitialized!]!
  marketResolved(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): MarketResolved
  marketResolveds(
    skip: Int = 0
    first: Int = 100
    orderBy: MarketResolved_orderBy
    orderDirection: OrderDirection
    where: MarketResolved_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [MarketResolved!]!
  tokensBought(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokensBought
  tokensBoughts(
    skip: Int = 0
    first: Int = 100
    orderBy: TokensBought_orderBy
    orderDirection: OrderDirection
    where: TokensBought_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokensBought!]!
  tokensCreated(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokensCreated
  tokensCreateds(
    skip: Int = 0
    first: Int = 100
    orderBy: TokensCreated_orderBy
    orderDirection: OrderDirection
    where: TokensCreated_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokensCreated!]!
  tokensRedeemed(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokensRedeemed
  tokensRedeemeds(
    skip: Int = 0
    first: Int = 100
    orderBy: TokensRedeemed_orderBy
    orderDirection: OrderDirection
    where: TokensRedeemed_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokensRedeemed!]!
  tokensSettled(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokensSettled
  tokensSettleds(
    skip: Int = 0
    first: Int = 100
    orderBy: TokensSettled_orderBy
    orderDirection: OrderDirection
    where: TokensSettled_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokensSettled!]!
  tokensSold(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokensSold
  tokensSolds(
    skip: Int = 0
    first: Int = 100
    orderBy: TokensSold_orderBy
    orderDirection: OrderDirection
    where: TokensSold_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokensSold!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

enum Aggregation_interval {
  hour
  day
}

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
  number_gte: Int!
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

scalar Bytes

"""
8 bytes signed integer

"""
scalar Int8

type MarketAsserted {
  id: Bytes!
  marketId: Bytes!
  assertedOutcome: String!
  assertionId: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

input MarketAsserted_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  marketId: Bytes
  marketId_not: Bytes
  marketId_gt: Bytes
  marketId_lt: Bytes
  marketId_gte: Bytes
  marketId_lte: Bytes
  marketId_in: [Bytes!]
  marketId_not_in: [Bytes!]
  marketId_contains: Bytes
  marketId_not_contains: Bytes
  assertedOutcome: String
  assertedOutcome_not: String
  assertedOutcome_gt: String
  assertedOutcome_lt: String
  assertedOutcome_gte: String
  assertedOutcome_lte: String
  assertedOutcome_in: [String!]
  assertedOutcome_not_in: [String!]
  assertedOutcome_contains: String
  assertedOutcome_contains_nocase: String
  assertedOutcome_not_contains: String
  assertedOutcome_not_contains_nocase: String
  assertedOutcome_starts_with: String
  assertedOutcome_starts_with_nocase: String
  assertedOutcome_not_starts_with: String
  assertedOutcome_not_starts_with_nocase: String
  assertedOutcome_ends_with: String
  assertedOutcome_ends_with_nocase: String
  assertedOutcome_not_ends_with: String
  assertedOutcome_not_ends_with_nocase: String
  assertionId: Bytes
  assertionId_not: Bytes
  assertionId_gt: Bytes
  assertionId_lt: Bytes
  assertionId_gte: Bytes
  assertionId_lte: Bytes
  assertionId_in: [Bytes!]
  assertionId_not_in: [Bytes!]
  assertionId_contains: Bytes
  assertionId_not_contains: Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [MarketAsserted_filter]
  or: [MarketAsserted_filter]
}

enum MarketAsserted_orderBy {
  id
  marketId
  assertedOutcome
  assertionId
  blockNumber
  blockTimestamp
  transactionHash
}

type MarketInitialized {
  id: Bytes!
  marketId: Bytes!
  outcome1: String!
  outcome2: String!
  description: String!
  outcome1Token: Bytes!
  outcome2Token: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

input MarketInitialized_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  marketId: Bytes
  marketId_not: Bytes
  marketId_gt: Bytes
  marketId_lt: Bytes
  marketId_gte: Bytes
  marketId_lte: Bytes
  marketId_in: [Bytes!]
  marketId_not_in: [Bytes!]
  marketId_contains: Bytes
  marketId_not_contains: Bytes
  outcome1: String
  outcome1_not: String
  outcome1_gt: String
  outcome1_lt: String
  outcome1_gte: String
  outcome1_lte: String
  outcome1_in: [String!]
  outcome1_not_in: [String!]
  outcome1_contains: String
  outcome1_contains_nocase: String
  outcome1_not_contains: String
  outcome1_not_contains_nocase: String
  outcome1_starts_with: String
  outcome1_starts_with_nocase: String
  outcome1_not_starts_with: String
  outcome1_not_starts_with_nocase: String
  outcome1_ends_with: String
  outcome1_ends_with_nocase: String
  outcome1_not_ends_with: String
  outcome1_not_ends_with_nocase: String
  outcome2: String
  outcome2_not: String
  outcome2_gt: String
  outcome2_lt: String
  outcome2_gte: String
  outcome2_lte: String
  outcome2_in: [String!]
  outcome2_not_in: [String!]
  outcome2_contains: String
  outcome2_contains_nocase: String
  outcome2_not_contains: String
  outcome2_not_contains_nocase: String
  outcome2_starts_with: String
  outcome2_starts_with_nocase: String
  outcome2_not_starts_with: String
  outcome2_not_starts_with_nocase: String
  outcome2_ends_with: String
  outcome2_ends_with_nocase: String
  outcome2_not_ends_with: String
  outcome2_not_ends_with_nocase: String
  description: String
  description_not: String
  description_gt: String
  description_lt: String
  description_gte: String
  description_lte: String
  description_in: [String!]
  description_not_in: [String!]
  description_contains: String
  description_contains_nocase: String
  description_not_contains: String
  description_not_contains_nocase: String
  description_starts_with: String
  description_starts_with_nocase: String
  description_not_starts_with: String
  description_not_starts_with_nocase: String
  description_ends_with: String
  description_ends_with_nocase: String
  description_not_ends_with: String
  description_not_ends_with_nocase: String
  outcome1Token: Bytes
  outcome1Token_not: Bytes
  outcome1Token_gt: Bytes
  outcome1Token_lt: Bytes
  outcome1Token_gte: Bytes
  outcome1Token_lte: Bytes
  outcome1Token_in: [Bytes!]
  outcome1Token_not_in: [Bytes!]
  outcome1Token_contains: Bytes
  outcome1Token_not_contains: Bytes
  outcome2Token: Bytes
  outcome2Token_not: Bytes
  outcome2Token_gt: Bytes
  outcome2Token_lt: Bytes
  outcome2Token_gte: Bytes
  outcome2Token_lte: Bytes
  outcome2Token_in: [Bytes!]
  outcome2Token_not_in: [Bytes!]
  outcome2Token_contains: Bytes
  outcome2Token_not_contains: Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [MarketInitialized_filter]
  or: [MarketInitialized_filter]
}

enum MarketInitialized_orderBy {
  id
  marketId
  outcome1
  outcome2
  description
  outcome1Token
  outcome2Token
  blockNumber
  blockTimestamp
  transactionHash
}

type MarketResolved {
  id: Bytes!
  marketId: Bytes!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

input MarketResolved_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  marketId: Bytes
  marketId_not: Bytes
  marketId_gt: Bytes
  marketId_lt: Bytes
  marketId_gte: Bytes
  marketId_lte: Bytes
  marketId_in: [Bytes!]
  marketId_not_in: [Bytes!]
  marketId_contains: Bytes
  marketId_not_contains: Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [MarketResolved_filter]
  or: [MarketResolved_filter]
}

enum MarketResolved_orderBy {
  id
  marketId
  blockNumber
  blockTimestamp
  transactionHash
}

"""Defines the order direction, either ascending or descending"""
enum OrderDirection {
  asc
  desc
}

"""
A string representation of microseconds UNIX timestamp (16 digits)

"""
scalar Timestamp

type TokensBought {
  id: Bytes!
  marketId: Bytes!
  account: Bytes!
  currencyAmount: BigInt!
  outcomeTokensBought: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

input TokensBought_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  marketId: Bytes
  marketId_not: Bytes
  marketId_gt: Bytes
  marketId_lt: Bytes
  marketId_gte: Bytes
  marketId_lte: Bytes
  marketId_in: [Bytes!]
  marketId_not_in: [Bytes!]
  marketId_contains: Bytes
  marketId_not_contains: Bytes
  account: Bytes
  account_not: Bytes
  account_gt: Bytes
  account_lt: Bytes
  account_gte: Bytes
  account_lte: Bytes
  account_in: [Bytes!]
  account_not_in: [Bytes!]
  account_contains: Bytes
  account_not_contains: Bytes
  currencyAmount: BigInt
  currencyAmount_not: BigInt
  currencyAmount_gt: BigInt
  currencyAmount_lt: BigInt
  currencyAmount_gte: BigInt
  currencyAmount_lte: BigInt
  currencyAmount_in: [BigInt!]
  currencyAmount_not_in: [BigInt!]
  outcomeTokensBought: BigInt
  outcomeTokensBought_not: BigInt
  outcomeTokensBought_gt: BigInt
  outcomeTokensBought_lt: BigInt
  outcomeTokensBought_gte: BigInt
  outcomeTokensBought_lte: BigInt
  outcomeTokensBought_in: [BigInt!]
  outcomeTokensBought_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [TokensBought_filter]
  or: [TokensBought_filter]
}

enum TokensBought_orderBy {
  id
  marketId
  account
  currencyAmount
  outcomeTokensBought
  blockNumber
  blockTimestamp
  transactionHash
}

type TokensCreated {
  id: Bytes!
  marketId: Bytes!
  account: Bytes!
  tokensCreated: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

input TokensCreated_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  marketId: Bytes
  marketId_not: Bytes
  marketId_gt: Bytes
  marketId_lt: Bytes
  marketId_gte: Bytes
  marketId_lte: Bytes
  marketId_in: [Bytes!]
  marketId_not_in: [Bytes!]
  marketId_contains: Bytes
  marketId_not_contains: Bytes
  account: Bytes
  account_not: Bytes
  account_gt: Bytes
  account_lt: Bytes
  account_gte: Bytes
  account_lte: Bytes
  account_in: [Bytes!]
  account_not_in: [Bytes!]
  account_contains: Bytes
  account_not_contains: Bytes
  tokensCreated: BigInt
  tokensCreated_not: BigInt
  tokensCreated_gt: BigInt
  tokensCreated_lt: BigInt
  tokensCreated_gte: BigInt
  tokensCreated_lte: BigInt
  tokensCreated_in: [BigInt!]
  tokensCreated_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [TokensCreated_filter]
  or: [TokensCreated_filter]
}

enum TokensCreated_orderBy {
  id
  marketId
  account
  tokensCreated
  blockNumber
  blockTimestamp
  transactionHash
}

type TokensRedeemed {
  id: Bytes!
  marketId: Bytes!
  account: Bytes!
  tokensRedeemed: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

input TokensRedeemed_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  marketId: Bytes
  marketId_not: Bytes
  marketId_gt: Bytes
  marketId_lt: Bytes
  marketId_gte: Bytes
  marketId_lte: Bytes
  marketId_in: [Bytes!]
  marketId_not_in: [Bytes!]
  marketId_contains: Bytes
  marketId_not_contains: Bytes
  account: Bytes
  account_not: Bytes
  account_gt: Bytes
  account_lt: Bytes
  account_gte: Bytes
  account_lte: Bytes
  account_in: [Bytes!]
  account_not_in: [Bytes!]
  account_contains: Bytes
  account_not_contains: Bytes
  tokensRedeemed: BigInt
  tokensRedeemed_not: BigInt
  tokensRedeemed_gt: BigInt
  tokensRedeemed_lt: BigInt
  tokensRedeemed_gte: BigInt
  tokensRedeemed_lte: BigInt
  tokensRedeemed_in: [BigInt!]
  tokensRedeemed_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [TokensRedeemed_filter]
  or: [TokensRedeemed_filter]
}

enum TokensRedeemed_orderBy {
  id
  marketId
  account
  tokensRedeemed
  blockNumber
  blockTimestamp
  transactionHash
}

type TokensSettled {
  id: Bytes!
  marketId: Bytes!
  account: Bytes!
  payout: BigInt!
  outcome1Tokens: BigInt!
  outcome2Tokens: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

input TokensSettled_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  marketId: Bytes
  marketId_not: Bytes
  marketId_gt: Bytes
  marketId_lt: Bytes
  marketId_gte: Bytes
  marketId_lte: Bytes
  marketId_in: [Bytes!]
  marketId_not_in: [Bytes!]
  marketId_contains: Bytes
  marketId_not_contains: Bytes
  account: Bytes
  account_not: Bytes
  account_gt: Bytes
  account_lt: Bytes
  account_gte: Bytes
  account_lte: Bytes
  account_in: [Bytes!]
  account_not_in: [Bytes!]
  account_contains: Bytes
  account_not_contains: Bytes
  payout: BigInt
  payout_not: BigInt
  payout_gt: BigInt
  payout_lt: BigInt
  payout_gte: BigInt
  payout_lte: BigInt
  payout_in: [BigInt!]
  payout_not_in: [BigInt!]
  outcome1Tokens: BigInt
  outcome1Tokens_not: BigInt
  outcome1Tokens_gt: BigInt
  outcome1Tokens_lt: BigInt
  outcome1Tokens_gte: BigInt
  outcome1Tokens_lte: BigInt
  outcome1Tokens_in: [BigInt!]
  outcome1Tokens_not_in: [BigInt!]
  outcome2Tokens: BigInt
  outcome2Tokens_not: BigInt
  outcome2Tokens_gt: BigInt
  outcome2Tokens_lt: BigInt
  outcome2Tokens_gte: BigInt
  outcome2Tokens_lte: BigInt
  outcome2Tokens_in: [BigInt!]
  outcome2Tokens_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [TokensSettled_filter]
  or: [TokensSettled_filter]
}

enum TokensSettled_orderBy {
  id
  marketId
  account
  payout
  outcome1Tokens
  outcome2Tokens
  blockNumber
  blockTimestamp
  transactionHash
}

type TokensSold {
  id: Bytes!
  marketId: Bytes!
  account: Bytes!
  currencyAmount: BigInt!
  outcomeTokensSold: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

input TokensSold_filter {
  id: Bytes
  id_not: Bytes
  id_gt: Bytes
  id_lt: Bytes
  id_gte: Bytes
  id_lte: Bytes
  id_in: [Bytes!]
  id_not_in: [Bytes!]
  id_contains: Bytes
  id_not_contains: Bytes
  marketId: Bytes
  marketId_not: Bytes
  marketId_gt: Bytes
  marketId_lt: Bytes
  marketId_gte: Bytes
  marketId_lte: Bytes
  marketId_in: [Bytes!]
  marketId_not_in: [Bytes!]
  marketId_contains: Bytes
  marketId_not_contains: Bytes
  account: Bytes
  account_not: Bytes
  account_gt: Bytes
  account_lt: Bytes
  account_gte: Bytes
  account_lte: Bytes
  account_in: [Bytes!]
  account_not_in: [Bytes!]
  account_contains: Bytes
  account_not_contains: Bytes
  currencyAmount: BigInt
  currencyAmount_not: BigInt
  currencyAmount_gt: BigInt
  currencyAmount_lt: BigInt
  currencyAmount_gte: BigInt
  currencyAmount_lte: BigInt
  currencyAmount_in: [BigInt!]
  currencyAmount_not_in: [BigInt!]
  outcomeTokensSold: BigInt
  outcomeTokensSold_not: BigInt
  outcomeTokensSold_gt: BigInt
  outcomeTokensSold_lt: BigInt
  outcomeTokensSold_gte: BigInt
  outcomeTokensSold_lte: BigInt
  outcomeTokensSold_in: [BigInt!]
  outcomeTokensSold_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  blockTimestamp: BigInt
  blockTimestamp_not: BigInt
  blockTimestamp_gt: BigInt
  blockTimestamp_lt: BigInt
  blockTimestamp_gte: BigInt
  blockTimestamp_lte: BigInt
  blockTimestamp_in: [BigInt!]
  blockTimestamp_not_in: [BigInt!]
  transactionHash: Bytes
  transactionHash_not: Bytes
  transactionHash_gt: Bytes
  transactionHash_lt: Bytes
  transactionHash_gte: Bytes
  transactionHash_lte: Bytes
  transactionHash_in: [Bytes!]
  transactionHash_not_in: [Bytes!]
  transactionHash_contains: Bytes
  transactionHash_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [TokensSold_filter]
  or: [TokensSold_filter]
}

enum TokensSold_orderBy {
  id
  marketId
  account
  currencyAmount
  outcomeTokensSold
  blockNumber
  blockTimestamp
  transactionHash
}

type _Block_ {
  """The hash of the block"""
  hash: Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
  """The hash of the parent block"""
  parentHash: Bytes
}

"""The type for the top-level _meta field"""
type _Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: _Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow
  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}